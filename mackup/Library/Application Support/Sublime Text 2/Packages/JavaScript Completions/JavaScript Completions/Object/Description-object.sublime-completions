{
  "scope": "source.js",
  "completions": [
    {
      "trigger": "description-Object",
      "contents": "/*\n\tDescription:\n\tThe Object constructor creates an object wrapper.\n\n\tSyntax:\n\t// Object initialiser or literal\n\t{ [ nameValuePair1 [, nameValuePair2 [, ...nameValuePairN] ] ] }\n\n\t// Called as a constructor\n\tnew Object( [ value ] )\n*/"
    },
    {
      "trigger": "description-Object.create()",
      "contents": "/*\n\tDescription:\n\tThe Object.create() method creates a new object with the specified prototype object and properties.\n\n\tSyntax:\n\tObject.create(proto[, propertiesObject])\n*/"
    },
    {
      "trigger": "description-Object.defineProperty()",
      "contents": "/*\n\tDescription:\n\tThe Object.defineProperty() method defines a new property directly on an object, or modifies an existing property on an object, and returns the object.\n\n\tSyntax:\n\tObject.defineProperty(obj, prop, descriptor)\n*/"
    },
    {
      "trigger": "description-Object.defineProperties()",
      "contents": "/*\n\tDescription:\n\tThe Object.defineProperties() method defines new or modifies existing properties directly on an object, returning the object.\n\n\tSyntax:\n\tObject.defineProperties(obj, props)\n*/"
    },
    {
      "trigger": "description-Object.freeze()",
      "contents": "/*\n\tDescription:\n\tThe Object.freeze() method freezes an object: that is, prevents new properties from being added to it; prevents existing properties from being removed; and prevents existing properties, or their enumerability, configurability, or writability, from being changed. In essence the object is made effectively immutable. The method returns the object being frozen.\n\n\tSyntax:\n\tObject.freeze(obj)\n*/"
    },
    {
      "trigger": "description-Object.getOwnPropertyDescriptor()",
      "contents": "/*\n\tDescription:\n\tThe Object.getOwnPropertyDescriptor() method returns a property descriptor for an own property (that is, one directly present on an object, not present by dint of being along an object's prototype chain) of a given object.\n\n\tSyntax:\n\tObject.getOwnPropertyDescriptor(obj, prop)\n*/"
    },
    {
      "trigger": "description-Object.getOwnPropertyNames()",
      "contents": "/*\n\tDescription:\n\tThe Object.getOwnPropertyNames() method returns an array of all properties (enumerable or not) found directly upon a given object.\n\n\tSyntax:\n\tObject.getOwnPropertyNames(obj)\n*/"
    },
    {
      "trigger": "description-Object.getPrototypeOf()",
      "contents": "/*\n\tDescription:\n\tThe Object.getPrototypeOf() method returns the prototype (i.e. the internal [[Prototype]]) of the specified object.\n\n\tSyntax:\n\tObject.getPrototypeOf(obj)\n*/"
    },
    {
      "trigger": "description-Object.isExtensible()",
      "contents": "/*\n\tDescription:\n\tThe Object.isExtensible() method determines if an object is extensible (whether it can have new properties added to it).\n\n\tSyntax:\n\tObject.isExtensible(obj)\n*/"
    },
    {
      "trigger": "description-Object.isFrozen()",
      "contents": "/*\n\tDescription:\n\tThe Object.isFrozen() determines if an object is frozen.\n\n\tSyntax:\n\tObject.isFrozen(obj)\n*/"
    },
    {
      "trigger": "description-Object.isSealed()",
      "contents": "/*\n\tDescription:\n\tThe Object.isSealed() method determines if an object is sealed.\n\n\tSyntax:\n\tObject.isSealed(obj)\n*/"
    },
    {
      "trigger": "description-Object.keys()",
      "contents": "/*\n\tDescription:\n\tThe Object.keys() method returns an array of a given object's own enumerable properties, in the same order as that provided by a for...in loop (the difference being that a for-in loop enumerates properties in the prototype chain as well).\n\n\tSyntax:\n\tObject.keys(obj)\n*/"
    },
    {
      "trigger": "description-Object.preventExtensions()",
      "contents": "/*\n\tDescription:\n\tThe Object.preventExtensions() method prevents new properties from ever being added to an object (i.e. prevents future extensions to the object).\n\n\tSyntax:\n\tObject.preventExtensions(obj)\n*/"
    },
    {
      "trigger": "description-Object.seal()",
      "contents": "/*\n\tDescription:\n\tThe Object.seal() method seals an object, preventing new properties from being added to it and marking all existing properties as non-configurable. Values of present properties can still be changed as long as they are writable.\n\n\tSyntax:\n\tObject.seal(obj)\n*/"
    },
    {
      "trigger": "description-Object.prototype.hasOwnProperty()",
      "contents": "/*\n\tDescription:\n\tThe hasOwnProperty() method returns a boolean indicating whether the object has the specified property.\n\n\tSyntax:\n\tobj.hasOwnProperty(prop)\n*/"
    },
    {
      "trigger": "description-Object.prototype.isPrototypeOf()",
      "contents": "/*\n\tDescription:\n\tThe isPrototypeOf() method tests for an object in another object's prototype chain.\n\n\tSyntax:\n\tprototypeObj.isPrototypeOf(obj)\n*/"
    },
    {
      "trigger": "description-Object.prototype.propertyIsEnumerable()",
      "contents": "/*\n\tDescription:\n\tThe propertyIsEnumerable() method returns a Boolean indicating whether the specified property is enumerable.\n\n\tSyntax:\n\tobj.propertyIsEnumerable(prop)\n*/"
    },
    {
      "trigger": "description-Object.prototype.toLocaleString()",
      "contents": "/*\n\tDescription:\n\tThe toLocaleString() method returns a string representing the object. This method is meant to be overriden by derived objects for locale-specific purposes.\n\n\tSyntax:\n\tobj.toLocaleString();\n*/"
    },
    {
      "trigger": "description-Object.prototype.toString()",
      "contents": "/*\n\tDescription:\n\tThe toString() method returns a string representing object.\n\n\tSyntax:\n\tobj.toString()\n*/"
    },
    {
      "trigger": "description-Object.prototype.valueOf()",
      "contents": "/*\n\tDescription:\n\tThe valueOf() method returns the primitive value of the specified object.\n\n\tSyntax:\n\tobject.valueOf()\n*/"
    }
  ]
}